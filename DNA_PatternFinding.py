
#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 1 .Counting patterns in a sequence
def PatternCount(Text, Pattern):
    count = 0
    window_len = len(Pattern)
    for i in range (0,len(Text)-window_len+1):
     window_act = Text[i:i+window_len]
     if window_act == Pattern:
      count += 1
    return int(count)

txt1 = "GGTATTGTCTGAGAGATTGTCTGGTTTGTCTGTTCCGTGTTTGTCTGTTGTCTGATTGTCTGTTGTTTGTCTGTTGTCTGCGATTGTCTGTTGTCTGATTGTCTGACCATTGTCTGGTTGTCTGATACGGGTTTGTCTGTGTGTTGTCTGTTTGTCTGCGACGGTGTTGTCTGTTGTCTGCAATTGTCTGTTCTTGTCTGTGGTCTTGTCTGGTTGTCTGCTTTATGGGTGTTGTCTGTTGTCTGACACTTTGTCTGCTTGTCTGTTGTCTGTTGTCTGACTTGTCTGAATTGTCTGATTCTTGTCTGCCATCCCGAACATTGTCTGATTGTCTGCATTGTCTGTTGTCTGTTGTCTGATTGTCTGAGTTTGTCTGCTAGTTGTCTGATCGTTTGTCTGGTTGTCTGTTTGTCTGCTTAAGATTTGTCTGAATTGTCTGTTTGTCTGAGCTTGTCTGTTGTCTGTTGTCGCTTGTCTGCGTTGTCTGTTGTCTGGAGCCATTGTCTGGTTGCAGACCCGAAGGTTGTCTGTTGTCTGACTGGTTTGTCTGGTTTGTCTGATTGTTGTCTGAAATCAGTGCCACTAGCTTGTCTGTTGTCTGATTAATTGTCTGTACAAGTTTGTCTGTTTGTCTGGCCCTTGTCTGATTGTCTGGTTGTCTGAAGAATCTGTGGTTGTCTGCTTCCTGGTTGTCTGTTGTCTGGGCCACGTTGTCTGCTTTGTCTGCCGATTGTCTGATTGTCTGCTGTTGTCTGGGTTGTCTGCGATTGTCTGTTGTCTGTTGTCTGTAGTTGTCTGTTGTCTGGTGTTTGTCTGGCCTTGTCTGGCTTGTCTGTTGTCTGCGCTTGTCTGTAGATTGTCTGCAACCCTTTTGTCTGGCGTTGTCTGTGTACTTTGTCTGTTGTCTGTTTGTCTGACTTGTCTGTTGTCTGTTAATCCTTTGTCTGGAGTTGTCTGGTTGTCTG"
ptrn = "TTGTCTGTT"

# print(f'The pattern {ptrn} is repeated {PatternCount(txt1,ptrn)} times in the given sequence')


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 2. Counting the frequency of patterns inside a sequence

txt1 = "CCCTCGGCCCCTCGGCTCATTCTACAATTTCGAGATCATACCTCATTCTAGATCATACCTCATTCTATGCCCGAACCCTCGGCGATCATACCTGCCCGAACAATTTCGATGCCCGAACCCTCGGCCAATTTCGATCATTCTAGATCATACCTGCCCGAACCCTCGGCCAATTTCGATGCCCGAAGATCATACCCAATTTCGATGCCCGAATCATTCTACAATTTCGATCATTCTACAATTTCGAGATCATACCTGCCCGAACAATTTCGACAATTTCGACCCTCGGCTCATTCTAGATCATACCTCATTCTATGCCCGAATCATTCTATGCCCGAATCATTCTACAATTTCGACAATTTCGACCCTCGGCTGCCCGAACAATTTCGACCCTCGGCTGCCCGAACAATTTCGACAATTTCGAGATCATACCTGCCCGAAGATCATACCCAATTTCGATGCCCGAATGCCCGAACAATTTCGACAATTTCGACAATTTCGACAATTTCGACAATTTCGACCCTCGGCGATCATACCGATCATACCTGCCCGAACCCTCGGCCCCTCGGCTGCCCGAAGATCATACCTCATTCTAGATCATACCCAATTTCGAGATCATACCGATCATACCTCATTCTATGCCCGAATGCCCGAAGATCATACCTCATTCTACCCTCGGCCCCTCGGCTCATTCTATGCCCGAAGATCATACCCCCTCGGCCAATTTCGATGCCCGAACAATTTCGACAATTTCGACCCTCGGCCCCTCGGCTCATTCTAGATCATACCCCCTCGGCGATCATACCTCATTCTACAATTTCGATCATTCTACCCTCGGCTCATTCTATGCCCGAATCATTCTACAATTTCGACAATTTCGATCATTCTATCATTCTATCATTCTACCCTCGGCGATCATACCCCCTCGGCTGCCCGAACCCTCGGCTCATTCTATGCCCGAA"
test_sequence='CGGAGGACTCTAGGTAACGCTTATCAGGTCCATAGGACATTCA'
def MaxPatternFreq(sequence, k, get_max=None):
    freq_map = {}
    len_pattern = k
    for i in range(0,len(sequence)-len_pattern+1):
      window_actual = sequence[i:i+len_pattern]
      if window_actual in freq_map:
        freq_map[window_actual] += 1
      else:
        freq_map[window_actual] = 1

    patterns = list(freq_map.keys())
    frequencies = list(freq_map.values())
    if get_max==True:
        max_actual = frequencies[0]
        for i in range(0,len(frequencies)):
            if max_actual < frequencies[i]:
               max_actual = frequencies[i]

        max_pattern_freq = {}
        for i in range(0,len(frequencies)):
            if frequencies[i] == max_actual:
               max_pattern_freq[patterns[i]]=frequencies[i]

        return max_pattern_freq
    else:
       return freq_map

print(MaxPatternFreq(test_sequence,3,True))


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 3. Complementary nucleotide sequence
sequence1 = 'TTCCCCTTATTCGCTTGTCGGTAAACAGCTATGCTCGTTGACGCTAGGTCCGAGTAGTTCGCCCGCCTAAAATGCCCCTCATGCATCGCCTAGTTCACCGCCGTTACCCGCTGCCCAAACCCAATCATTAGGGTCTCCGTATAGAATACGAGTTCCACTAGGGTAGTGAAGGCGTACTGGCTCGCACCCGCTGAATTCCTGGCGCTGATGGTTCTCCTCCTTCGGGTTCGGCGCGATTTATGAGGACTAATCGCGCAACCCCAATAACGCGCTCCGTATACTGTCGGGATCTCAGGGCCTCAGAGGAGCCTTATGAGGCAATAATGTATTTAACCCTTGCTCCTGCTCTTAAGCCGGTACAGGCGCTCAAGGAATTTGAGGGCGGACACTACCTCATTGACTGATCATGGATCATGTCTAGCCACAGGTGATGTAGCTGACATGTGAGAGAACGTAAGCATGTAACTGCCCCGTCTTGCTAGGGGTTTGTATAGCCGTACTAGCTGGAACAAAAGCTATCAGCTCGGCTTGTTTTGGGTCCCGAACATAAGCCCACCTACCTCAGAAGCTCTTGAGTATTAAAGCGGGGACGTAGGGCTTTAACTTGGTAATTGTCAGTTGTGCGGTCACACTACGTGTGTGCGAGTTATGAGCACGATATTCTAAATCAGGATGTGCTGCACCTTTTGCCTCTAAGGATTGGGCATTCCACGTTTTCGACATGTACATGCCTCAAAGTCCCCGGCCGAATGTTACAAGCCACGATCTGTCACGCCGACACGCCAATGAGCCCCCCTATTGGTTCCGCGGTAAGGTGTGAACACCGCGCCATGTTATGCTTATAACCGGCATTAGTTAGCCGACCGTCCATCGTAGTCTCCTAGCGAACTGAATTGGTACTGTTGCAGATCCAGCTCTGGGGATGCTGCGGCAGTGACATAATTGTTACTCTATCCCTGACTTACATCGTCATAAATCCAGTTGTGCAAGGGTGATTCCCTGGGGATAAACATACCACCACGGTTAAGAGACGAGTGGAGCGCCTATTCGAACGGCCCCATAGCGTTCCCGAGTTCGGTCGAGGTGTGCCTAGTCCATCCAACAGATAGATACAAAGATTAGACCGTTTGTAGGAGACTTGCCGACCAGTATCGCACCTTAGCTAGAGCGGTAAATAGTCGACAAAGACGTTCACGGGGGCATGGAATTGATCTTGGGGACGATGAGCAGCTGTTAAGATGCACTTCAAGACTCCACGTCCTACATCATTCTGCATAGGACTTACGCAAGTACTGTTCCACTCAGAGGCATATCAAAACGCACCAAATCGTGGGAATCGATAGGTGTGCTTACTCCTCCACTTCTCTCTACCTCCTCAAATCACGAACACCAAGACCAGTTGGTAAGGTCTTTGGAGCGCAGTCAACCAGATGGGCTTATAGGAATGATAGGACACTACATCCTGTCGCTTTATCCAAAATGTCACTAGAGGGTGATACTACTGTCAAATGGGTACCGAGAGGATCATAAAACCTACGGCAGAAGAAGGCGAAATTGCCGATGTGGGTGCTACTACGGGCGATATACCCTCCCGCAGGTGTCTTAGTCGGGTCAATTCTGTAAATTCCCCTTATCATGCATGACCAACCCAGCTCCAGCCAACCCGCGTGCGAGGTGGTTCTAAGCCTTATCGCGAGGTAACACCCCGGCATGTACGATTCCCACTGACGTGGAGCCGGAGGGGCATAGCCAACCGCAGTGACAGTTGCGCCGTGTCGATGATTCTGTTCTGGTAAGACATAAACGGCATTGAGTTCCGAATACTGCGAGGATACGAGAGTTTATCTGTGTACGAATCTGTGTAGAACCCGAGGGCTTGGGACCACAGATTCACGTGTTGGAATCTACAAACTTCCCATATACAATAGGCTCCTATTAGGCGCCGCGGCTTAATTGCCTTGTGTTCTGCACAGTTGCAAGAGATGGCTTCTTGTGCGCAAAACCCGACTCCTGGTGGGTTCCGAGGTGAATGCATTGATCGCTGTCAGTCCTCTCAGACAAGGTTGAATTACCCGGTGTTAGCTAAGCTAGACCTGAGGGGTCCCACTTGTGCCTAGTTGAAAATATTCATGGTTATTGCCCTTAAGCAGTGGAATCTTGGGCCATGAATACCATAACATTGAGCGTCTGTAGTCGGCTGGGGTAGATACCCGAGTGGCTGTCGCCTCACGTGGTCGCACAGTCACGATAACGGAGACCTCTCCGCACACCCTAGATAGCCTATCCAAGGCTTCTAGGTAATCTCCCCTGACTGCCATTTGCGGCTCGAGCCATCCCAAATGGGCCTTTCGAAGCAAACTCCAAACGGTGGTTTCAATATTGGAGTTTACCGCCGCAGATAAGACCGGACTGTCACCACTGCATTTAATGAGAGATTGTGCCCGGACCTCGCAGCTCCGGTCTCCTGTGCGGACTTTACCCGAGTAATTGTGACCTTTCCGCACTGTCATGAGAACTTATTATGGGGCTTAACCGTATGTAAGAGGATCGCCCGGAAAACATGGGAGACATGCAGTCGCTTGGGACGTTCGCCACAGTCCCTCCTCTGTCCTCCGTCCCGCCGTCACGTATATCTGGGGAGCGTGCGAGGTCGTGGCACTAGGGGACCTGATATCTAGTTCAAGTCCTTAATTTTCGAGACTCTACGACAATCACTGGCCCTTTTAATATTAATGTGGGGTCTCCATTATCGTTAGTGCTAGATCAAACACCTTACCAGAAAAGGCCGTGATTGGAAAGGTTCACATGACACACCTAAGCGCATCGTGCTACGTCTGGTTTGTACCTTATTTCTGCAAGCTGCCACCACTAGGGCTGTGTCGGAGAGAGTTGTTTAATCCACAACCGATTATCCCTGCAGAGGGAAGTCCCACATTCGCAATCCAAGTAGGTGCGCCTTGTTCTGCTGCACTTACCATTTCTACAAATGAACCGGACGTCTGTTGCTGCTGGCTGGAGATAAGCACACCCGATACAGGGGCCTCCCTTGCCGCCCTTACGAGAGAGACCATTGACAACCGAATACGAATGTTGGGCTCTAGACCTTGTAGAGGCACGAAAATCTCTTAACACCAGAGTGCATACACATGTACTCCCACTTACATGTTCTCACGGGCATCCTAAGGCATGGCATGTACGTCACGATGGATGCGGAAACAGCCGGCCGTCTACTACATCATTGTGCTCGGAATATGATGTGAATGGTACTTGCCAGTGGCCTTCTGATTCCAGAAAATTAACAAACAGTTCGATACGCTCTTAAAACAAGCGGGAGAGGCCGACCCTCGTTGGAGGTGATTTCAACCACACTGCCGCACCCCGTGCCGGGGTTTGCCCCTATCTTGCGCACGAGTCTATGTCTCGACCGTAGGATCCGTTCACAAGGCACTTGGGCCCACCCGGGTAGTCGGGGTATCGGTTATGTGGCTCTAGGATGGTAATTAACTAGTGAGACCTCGTACCTGTCCTACGCCACGTTTCGGTCCGTCAGCCGCCAGCTGCTTAGAGACACGAGTAATATTAGAGCGACTGTGCGTACTCTGTAGTGGAAAGGGAAAACGGTATGAGGCAACTAAGCTCACTCATCGTACTGGGCAATTCAAGCTGGAAAGCGAACGTACCATCTACGATTGAGCGTTGACCAGTCTATCAATACATACTAGCGTAAACGTTCCGTGCCAACCAGAGTACACTACACGTTAGTAGTTCGCATACTGCGACATCGCTACGTGAAGCCTGCCACGCATCACATAATTTCATAAACTATAGGATAGTTCACTCGGGTTCAACTACAATACCGGAACGTGGGAGAGTGGAGTATTATAGTAATTTAAACCCTTCTTAACTCACTATAGAGAAATTCCTGAAGGATTACCGCCTACAAAGAACAAAGTGTGCTAAATCAGAAATATAACTTCACAAGGCCTGTGTATCTGTTATCAATTTGTTGGTGTTAGCTTTATTGTATATAGAATAGGGGACGCCATTGTAACGCGCAGTCCGAAGTGATTGTGTCCTTAGTACATTTATTAGCTACTCAATCCATGAATTGGCGACATCCCGGTCATTAGCCTCTGTTCGCATAGATACGACGCGCCGGCCTCTGGAGCACTCGTGTCCCACTAAGCCATCGATCTGAGCTGCGCGTATCAGGTTCCTGCCCTACTGTGCCAGTACGCTTGTGTGAGGTGATCACCTAGCTCTCATGACAGACACATCATGCTCCCAACTCTTCATAGTAAGGTGGGGGGGCCCAACTCCAGACCAGTTACTACACAACGCATGCTCTTTATTTTGCCCTGCATGTCGTTTGGAGCGTTACCATTTTTGCGTGTACTCGTTTATCCAGTGACATGTCAGGGAAAGTGCTAGAATAGATCCGACGCAGCACCGGCTTAGTCATTGGCGCGTCTACCTGATTCAATCGCCTATTCGGCTGATCTTTCTTTGGTATGCGAGTCCAGTAGGCCGCGGCCTTGGTAGTCCGTTACTCGTGCGGCTCGTGCATCCGTTATAGATGGTAGTTCACGTTTCTTGCCCCCCAAAGTACTCCTTCCCTTTACCCCTCCCTGGAGTAATATAAGTTAACTAACTTTCTGACCGTATGCATCGTGCACAAACCACAGTTCAAGCGCGGTTGCTGCCAGGGTCTCAGATGTATTTTGTCTTATTGACGGCCTTGTCCCGTTATAGCAACGATGAGGGTCAAACAGTATAAGTCGACTATTGAAACTAGGGTAGGACCAGAACCATTATGGTGGAAATAGGCACTCTTGAGTAAGCTTCGCGAGCGTAGCTGATATGGCCATGCAAATAATAGTCTTTGGGTCCAACATGATAGTCTGTTCTCGGTTATAGCAGGTGGACCAACAGATTTAAACGTTCCTGACTATTAGCCTGGAAGCAAGCCGAGAAGACATTTACCGAATGCCTATGATCACGCGCCTCACAAGGCGTCGAACAAGATTTCCGTCTGAGGGCAGGCGGTCTGGGGCGCTATCCTGGTAAGACTGACAATTATCCGGGTTGTTGGGTTGGCGTTTAATGAGCCACGAACGGTCTTCATCTAATGTACAGCGTTAATTCGTGACGGTCAGTCGTTAACGGGCTCATATTGGTTTGGATACAACGGACAGGTTCAGATAATAATACAGCAGCCGCCCGATGATATCAGCCTTCGGGATACCACCCCTGTGGTGATAACTACGTAGATCTACCGCGCAGCAATTGTGAGAAGGTTCCTGGCGGGGGCACCTCCTCATGTCATGAAGGGAGGAAGCGCTCACTTCGGGTTTCGAGCTCGGCCCACAGCACCTTAGGACCGGTGATGCACATACTAGGAATGAAAATCCTGAGAGGAGTCGAGCACAACACTTCTCGGGTTCGGAGTTATCCTAATTATGAATAGGATGTCATTTGACCGAGTTAAGTTTGCCAACACTATCAAAGGCATACTACGTTCGCGCAAAGCCGGCCTAGAGGACTGAGATAGTCGTAGCGTCTCTTAGAAGGGATTCTACCGTGCCGTCGCTATGGGGGTTATATCGCAGTCGCTCTGAAATGGAATGTCCTGACAGTACGTCATGAGCAGATGGCGACTGGTGAGACCTTCGGCTCCATTACTTGAGGCCCATACCCGGGATCCCCACATCCCTCGGTATGTCCCTCGTCCTTAGTGTGTCGCGTATATCGCTACCGAGGGGATAAGTATATAGTTCGAGGGCCCTCAGGAGGTACGTATGTTTTGTCAACGTTTATAGCCCAATTAACCGGGGGGGGTGTTTGTCTACTCCGTACATCCACAGAACCCTCGCGCAAACCCAGAACGATGATAACCTGTCTCCCTTTTGCGACAGTATATGCGGCCATAATTCTCTGGGGAGGTTTAAAAGCAGAAGAGCGTGCATCCTCGCTTCCGGAGGCGGCCAACCTGGATGATACCGGTCGGCCAGTTAACGTACAAAAGTAACATAGAGGCATAGACAGTTACGTGCAGTTCATGAAGCCGCACCACGTGGCTGACATTTTCCACTATGCGGCCTTGTATTTCCTGACGTCCAGTAATCTGAATGCCGGGTCTTACCTAGAAACACGCCACCTCTCCCATCAGCTCTGGATGACCGCGACGGAAGGTGATGAACCTGCCACTCCTAAGTGTAAGCAGAATCGCCGCTCAATGGAGACGGCATACTATATCCCGGCCTGCCCTTAGAATCGGCACGATCTCTGCACGCGGTTAGAAGTACGAATGTGTCAACGATAGTAGTGCGTCGATCGACCTCCTCCTCAAGGCATCTAGACATGCCCGCGACTGGTAGGCACTGCTCAGAAGCAAGGAGTATGAGACCGTTGATGGTAGTTCATCAGAGGTGGGGTTCATGAGTCGTACTGATAAAAGTTGGGTCTTCATATAGTTATTTGAGTTCGGGTTACCAACAAACGCGATATGGGTAGCTGTGTGTCTAGTATTACCAGTATTCTTCTTTCAGACAGCCTGGTCGGCGTACGCCCCCGAAGTCCATAGTTAGGTCAATTCCCCAAGCTCTCAAGGTGCCTCAAGCGCGAATGCCCGTATGACGCTGAGAAAATGGTTGTAATAAGAGATGATACTACAGACGAGGATTAAAATCTATTATTGTAATTCAGGGAGATCCTTTTCTCTTCGCCGGGAACAGAAATCTCAGTACGGGCAAAATCATTGCGGGGTATGGCAGTAGTATATTCCAGCTGAAGCAGATTGACCTACCCAGAGATCTCTCCCTAAACCGTGGACTCAAAGGAAGGTGGAGCTCCACTCGGAATCACAGTCGGGAGCGTGGATCGGATGCACACAATGTCTTGAGACATTTGCTGAGCTGATTCAAGCCTACAAGACCTAGGTTTCGTTATCGGTAACTTCAAAAACGGTCCCGTTGCGGGCAAGATACCAAAGCGGGTCGAATCGATGTTGGCGACTTCCCTCCAGCGGGTCTAAGGCTTCAAGTCGTGTGGTAATGCCACTCTCCCATTTATCCGCGCTTACGCGCCTATGGCCGTTCGGAGAACGGTCATTCCAAAATTTTCAGGTGCGATCTTCATGCGCTCCGAAATGAGCAACTCGTCCCTGCTGACTGGGCGTTGTCCGAGCGAATTTCCAATAGTTTAATAGGCACGGTATCCGCTATCATTTAGTTTGGCAGCCACGGTAAAACGAGACGTTGCACTCTGTCGGTCTCAAAGAAGTTCTCCATCCTGGCGTTGCAGACTTTCCAAGCCGGTCTGTGCAGGATCTTTCTCTATTAAATTCACATGATGGACCAAATATAATCGGTTGGGAACAGAGATCAGTACTACGCCAATTAAACTCGTTGGATCGATCAGGAGCATTAACGTCTCCACGGCCCACAACAAGAACTCCGCTATAGAATAGAATTACACCCCGTCGAATAGGACTCAACCGAGGGCTTCGGACCACCGTCGTAAGCGCCACAGGCTTTCTCTTTGACGCTGTGGTGGCGAAGCCAAACGTGGTTACGCGCTCTGGACAAACCGCATATAGTATTCGCATGTAAAGGCCCTGCTGGTTCCGAGCCTGGATGCGAATAGTGAGTCCAATTAGCCAAGCTACCCTTGCGCCCCAAGGGAGGGAGTTGGATAGTGGATATAGAAAGTTATCTGTTTCAATTCTCCTGAGGTAAGAGATACACAAGTAGGCTGTTAGTACCCTAGTTAGACATGTTCCGCATAGGAGAGGCGGGAAAGTTCTTGAAGGGAAGGACCGCTAGTGTTCAATTAGTGATCAAAAACTCACCGTAGGACATTTACCGCGAGCGTGTGAACGCGACGAGCATGTCACTCAGTCCTCCGTGTTAACAACTGGATGCCACGTCCGAAGAAGGTAGATGTGCGTTATTCAGATATTTAAATAGAAAGGCATATTCTCTCTCATACGTAGGTACCTATTATCGCCACGTACAATCATGGCATTGAGATGCATGAGAGGTGCCTCACTCTGTGCTTCATACGCAAGCTCCTAAGGATATTCCAGATCGAGCACTTGCAACGCATCCCGTTGGCTAACGTATAAATACGGGGGGAACGACCAGTCTTGACAGATTGACTTAGGGACGGGGTCATACGTATTATTCGCATGGGAACCATGAGAAAGTTGCTCGAGAACCGCCTTCCGAGTGCGCTTGTTTACCCGTATACGTCTATTGACCCCGTTGAGACCTATCTCTTTCGAATAGGGGATCCTACTTTTCTCTGGACAGGGTACTTCTGAAGTCGGTCGAAACGTCAGAACTTTCGAGTGTGATTCAGTCGGTTACGTAATTAAACTTGATTGAAGGCTTGAGAAGAATTTGGGCCACTCTTCGGTCCGCTCGAACGGCGCGTGAGGGTCTCAAATGATGCACCGCTGTCCCGGCATAAGATCGTCCCCTACACATTATTGGAGCCTGCCACGAGATTCGCTAGCGAAAGGTAAAAGCGAATCTGACGCTCAGATCCGCACCTTGTCCCTAAATCAATCGCGGCGAGCCTGTCAGGTACTGGCTACTCAAGATCCTACGTAGGTGACGCGCTATGAACAGACGCCACTATCGTTTACGGGGCTTACGAAGATTTGACGGGTCGATGAAATCGAACTGCGGTGCGCCCAGTGCTCACCAGTTATAGCGAGAATGTATGGGACCGATTTGCTCAGTACAGGGTTCTACCACTTTGGATGCAAAGCATCTAGCCCATGTATACATGTTGGACTCATATTTCGTTGGAGCGCAATTGTTGGGGTATCACTTGAGTAAAAGAGACCATCGCCTCAAGTCCCATGGGCTGATGTTAGTCCATGCTAATTTCTGATACAGAACGGTCGCAGCCTCCACGGGCCGTGGGCCCGTCCGGAAGGCAGGGTTTCCGTACATGCCGTACACATGTGCAGTGCTCTTCAGTCCGCGCTGTATGTTCTGTGGTCGTTCGCCG'
test_sequence2 = 'TTGTGTC'
def get_complementary_sequence(dna_template_sequence):
    dna_complements = {'A':'T','T':'A','C':'G','G':'C'}
    dna_complementary_sequence = ''
    for nucleotide in dna_template_sequence:
       comp_nucleotide = dna_complements[nucleotide]
       dna_complementary_sequence = dna_complementary_sequence + str(comp_nucleotide)

    #Flip the sequence to read 5' -> 3'
    reversed_dna_complementary_sequence = dna_complementary_sequence[::-1]

    return reversed_dna_complementary_sequence

print(get_complementary_sequence(test_sequence2))


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 4. Pattern finding for an specific pattern on a genome
import pandas as pd
data = pd.read_csv('./Data/Vibrio_cholerae.txt',delimiter='\t',header=None)
sequence2 = data.values.flatten()[0]
pattern2 = 'CTTGATCAT'
pattern3 = 'ATGATCAAG'
def pattern_finding(pattern, dna_sequence):
    pattern_len = len(pattern)
    patternFinding_dna_index = []
    for i in range(0,len(dna_sequence)-pattern_len+1):
       actual_window = dna_sequence[i:i+pattern_len]
       if actual_window == pattern:
          patternFinding_dna_index.append(i)
    space_separated_string = ' '.join(str(element) for element in patternFinding_dna_index)
    return space_separated_string

# print(pattern_finding(pattern2,sequence2))

#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////# 5. Clump finding algorithm
#Genome sequence -> the dna sequence where we want to find clumps
#k -> lenght of the k-mers to find
#L -> lenght of the window
#t -> threshold of how many k-mears should form a clump in the sequence.

import pandas as pd
from tqdm import tqdm
data = pd.read_csv('./Data/EColi_genome.txt',delimiter='\t',header=None)
sequence = data.values.flatten()[0]

# sequence = 'TCCACCGTGACCTCTGCAAATTATTATAGCTCTGCAAATTTAACCTTGGTGATCAGGAAGCGAAGCGCGAAGCGAATGGTACTGTTTTACACGAGACCCCGTTCCCATCTCCCCGGTGTATTCTGCGAAATACAAGCGGCGAGCGCGGCTGCCCGAAAACCAGATCAATCTATGGCCAGGTAGCCGGCTTGCCGTTGCCGCACAGGCAAGTCCATACTTTAGGCCGTCGCGATCACCAGTCTGTACGCGATATGGAAAGGTAAATCGTTAAACCTGCTAGCGGATCTATTTTTGCGATGATCTATTCACTGTAAAATGCTGCGCAGCCAATAAATTGGGACGCGTAATAATTGCCCCACACGTTGGCTACCGCGTATCGCCAGATCAGCTCTTTGTGCAATTTGCTCCTCTTCAACACTCATGACGTGCGCGCTTATCTCATCGCGCACCTTTATTAAGGCCTGCTAGTAAGCAAGCGCTGGCAACTAGGGAAGGGCTTCTTGCGGCACAAGATACGTCGCAGTCTGCATAGATCCCCCCCTGATGCTCTGATGTCGATCTGATGTCGGGTCCGCACATGTCGCCAATCGCCGAGGTTGTCAGGCATCCTTAAAACATTCCCCCTAAGTTCGCAGGCCTGTTGAGAGCGATGGGTTTAATCCGGATGGCTTGTTGGAGAAGGAGGAGCCGTTAGCTGTGGAGGCTAGCGTTCGCTGTTCGCTGGCTGGCCGCTGGCCACACTGCCACACACACACTGCCAGTTCCGCTATCCCTGATTAAGTCCGTTACTTCACACTTTATTACGTGCCTGATAACAGCTATGTTAGACTAGATAAGACTGACACTGACCGCACACACTGACCGCGTCGGTATTGAACGCATTTACCTTGGCGGAAGAACATTACCTCATATTAAGGAATAAAGCGCTCCCAGACCAGCGTACTGGGCCTGGGAGCGCCTATTCTAAGTAAAACGTATCCGAATTGTGTGTTGTTCTACGAGGAACCGGGCAGCCCGTCCTAGTCTAGAGAGTGTGCACCAGGATGTTGGCTCATACTAACCCTAATGCCTGCCTGCCTCGGCCCGCCTCGGCGCCTGAGCCCTTGTGGACTTGCTGTGTTAATACCCGGCCGCAATCGTCAAAAGGGCCTCATTGTCGGGATGACAGGATCTTCCGATCCTAGCTTATCGGCCTAACCTACGACAAGTTGTATGGACTGGTAATCTGACGTGGAGTGGCGTCGGCTTCTTCACTGGCGACTTCACTGACTGTCTTGCAGTGTTAATCTACCTCCTTCGGTGCTACGTCAGGTGATGGTGTGCTGTTGGGACAATGTTCTCCGCACAAATGCCGAACGGGAGGTGAGTAACTTTAACAACTTTAACACAACAACCTACAAATTCACTTACGATGGTCTTAAACAAACACTACAACTAGCGCAAAAAACTGTCAGGAATCCTGGAGTCTTTAGGCGGTACATAAGTACAATATTTCGAGGAATGGCCGGCGCAGGACCACGATAGGCTCGGAGCGACGTCTTTAGTAACGCACCACCCCGAACTTTATCGATGCAATTTAGCAGTGTTGATGTCATTTAGCACGCTGAGTCTGCGTTTATACAAACGGGGACGGATCCGGGCACCAACTGTAGGATGTATCACTGACTTACGATCCTAGACCCCTACGGCACAAGCTTTTCGGCTTTTCGGCTTTTCGGCTTTTCGGCTTTTCGGCTTTTCG'
k = 9
L = 500
t = 3

def sequence_clump_finder(genome_sequence, k, L, t):
    clump_patterns = {}
    for i in tqdm(range(0,len(genome_sequence)-L+1),'Processing: '):
        actual_genome_window = genome_sequence[i:i+L]
        frequnet_patterns_window = MaxPatternFreq(actual_genome_window,k)
        frequencies = list(frequnet_patterns_window.values())
        patterns = list(frequnet_patterns_window.keys())
        for j in range(0,len(frequencies)):
           pattern_actual = patterns[j]
           if frequencies[j] >= t:
                if pattern_actual in clump_patterns:
                    clump_patterns[pattern_actual] += 1
                else:
                    clump_patterns[pattern_actual] = 1

    return clump_patterns
clumps = sequence_clump_finder(sequence,k,L,t)
print(len(clumps))



#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 6. Skew function
'''
 Funtion that counts the difference between G-C content aloing a linearized genome. This is called "Skew diagram"

'''
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

def skew_couinter_func(genome):
    skew_i = 0
    c_counter = 0
    g_counter = 0
    skew_val = [skew_i]
    for i in range(0,len(genome)):
         if genome[i] == 'C':
             c_counter +=1
         elif genome[i] == 'G':
             g_counter +=1
         skew_i = g_counter-c_counter
         skew_val.append(skew_i)

    plt.plot(np.arange(len(genome)+1),skew_val,'-o')
    plt.xlabel('Genome position') 
    plt.ylabel('skew (G-C)')
    plt.show()
    return (skew_val)

data = pd.read_csv('./Data/dataset_7_10.txt',delimiter='\t',header=None)
test_genome = data.values.flatten()[0]
genome_skew = skew_couinter_func(test_genome)

#We now that the ori of the genome should be on the more negative difference of G-C. Let's find the minimum
# of the graphic.

min_skew = np.min(genome_skew)
min_skew_indices = [index for index, value in enumerate(genome_skew) if value == min_skew]

#Remember that the position 0 of the return of function skew is 0 because we initialize skew(i=0)=0 so, the real
# positions of the genome now start from 1. in other words, genome_skew is |test_genome|+1 in lenght.

print('Minimum skew: ',min_skew)
print('Genome position(s) of the minimum: ', min_skew_indices)
print('Test genome: ',test_genome)


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 7. Hamming distance problem
def calculate_hamming_distance(string1, string2):
    hamming_dist = 0
    try:
        for i in range(0,len(string1)):
           if string1[i] != string2[i]:
              hamming_dist +=1
        return hamming_dist
    except:
       print('String1 and string2 do not have the same lenght')
       

string1_test = 'GGGCCGTTGGT'
string2_test = 'GGACCGTTGAC'

sequence_test1 = 'CCTAACCGTGAGGAATACTGAATACCTGGGTCTCCCCTGAGGGCGTAGCAGTATGTCTCATGGTGTACCGGCAGTTTTAGCGGGGCAGTTCGTCGGCGTCATCCAGGGTGGGTACTACACTCTAGAGGTCCAATGGGACATAAACGTACAGGTATTAGCTCCCACCGACGGGTGCCGTTGGGAGCTTGTGTTATGTGGTGTAAGTGGGTGGTGCGGCCCCTTACTCCACGGAGTACCCATATACCCTCGTAATTAATACTTCTCATATACAACAGGAAGCCCTAACTTAGTGCCTGGGTCACATCTAGTGCGAATTTTGTCAGAACCCTCGTCGCCTACTAGTTCACGAACAGTGACAGTATACTCGTACCATTCTAAGATTCTCATTAGGACTCAAGGCATGCACGGGTAGCTGGCCCTATCGGTGCCACATCAGAGTCACTGGGCTATAGCGATCGCGCTGGACCCTCCTGATGATAATGCTGAGGACAGATGTGCCGCGGTGGTCTAACTCAACTGTTCATCATGGGTTTTCTCCACTTCCACAGCACCTGATATACCGCATGGCTGTCTGTAGCAATTATAAGGACAGATTTGCCGTACTCTGTTGGCTTCTCGGGGTTAAGTCGTGTCGGGTGACCAGCCCCGACGGCCGCTCGTCCTTAAACGGCGACGGCCGTACATGTACGAACTATACTAGACCGTCGGCGTTGACCCTCACTCATCTAAGCAAAGTTAAAGCCGCTGCCTAGTTCTACCGCTAATTGGGTATTCACATGATCTTATCCCGAGATCCCCGCTGACGTAATTCCACGGCCGCGTACTTTGTACGGCCCAATTTTCAGGCTTAGTTGACCAAGTCACAACATCGAATAGTGGGATATTGCAGTTTACCCCATCAACCTAGTTGGGCTGGCCACCGAAACGGTTTCGACCTGTGTCAAATCTGGCGATACGTGCCAGAACTGGGATCACTCTTGTCACGCCACGACTGGGTCAATGTTACAGCTGGGCCATGCTGACACCCCCTGTGG'

sequence_test2 = 'TGCCCGCGTAATTTTCCTCCGAGGTGACGTCCATAAGTGGTATGCTAATCAGACCGATGGGCCTGCAGGCGCGTTGCTCCTTTCAGTCCACATCCCTTACATTATAGACGCGACGTACCGGGACGTGGCGCTGAAGTGATGAAGGAAGCACACTGCTTATAATCCGAAAGTAGATGCGCTGTCATGTGAAAAGAACGGCTGGGTGGAGTAATATTGGCGTATGTGTTAGTGACTTATCTCAAATAAAACCGCCGTTGCCAACTGCTAGCAATAACAGTCTTCTGCCTGATATCGCCATCATCAAAATATACATACGTCGTACTAACCGCGAAACGTACGCATAGTGATAAGTTTTTCGACGCCAGCTAGCTATCCCTTCATAGCTGTATGCCGTCAACGTAGGTGAAGATAGTTGCACATGTAGAACACCCCAAAGCATGACGAACGTGCCCGTTTCTCAGCACATATACGGCCAATCGAACGACAGAGGTGAGTAGTACGCGTCCAGGAGATCGGCGGAACCCAAGGAGGGTCATATAGAGGGGGTGAGTTCTGGTGGACTTCATATCGTCTAAGGAGCTATAGCTAAAAAATGTTCATAAGGGGCGCTATGTGCACTACACTTCTAGGATTGCAATGCTGCGCGTTTAAGGGACTTTATTTATGGTAACTGGTCGTCGGCGCTGAGCTAAGATTGTGTAGAGTTAGACAGGCACGATATCGGGGTATAACCCTAATGACTGAAAATTACAGCCTTTCATACGTTCACGCGCGTGCGCGCCTTTTTAGCTCCAGTTAGTCCTCCTATGCTCAGCGAAACAGCACCGAGGTGGCTCAGAAAATGTGCCGCATGGCTCCTTGTTAGTTGTAGCTGGTATACAATGGCGTTGAAGGAGATTGCCCGCGCAGTTGTAGAATGAATCGTGTCTGCGCAATGTTCCTGACTGTTCGTTTTCAGTGAGTGCGCGTCAGAGGCTTGGGGTACAGGTAGTTGACGTACCTAATACAACAACGCGCCATGTCTGTTGCAAGGA'

print(calculate_hamming_distance(sequence_test1,sequence_test2))


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 8. Approximate Pattern Matching Problem
#d - Max variation to consider for the hamming distance
'''''
    This function will print the index of the genome where the pattern matches with at most d variations with the
    genome,
'''''

def aprox_pattern_matching(sequence, pattern, d):
    pattern_len = len(pattern)
    patternFinding_dna_index = []
    for i in range(0,len(sequence)-pattern_len+1):
       actual_window = sequence[i:i+pattern_len]
       hamming_distance = calculate_hamming_distance(actual_window,pattern)
       if hamming_distance <= d:
          patternFinding_dna_index.append(i)
    # space_separated_string = ' '.join(str(element) for element in patternFinding_dna_index)
    return patternFinding_dna_index


#PARAMETERS

#Sample try
sequence_test = 'TTTAGAGCCTTCAGAGG'
d_test = 2
pattern_test = 'GAGG'

#Excercise 1 
import pandas as pd
data = pd.read_csv('./Data/dataset_8_10.txt',delimiter='\t',header=None)
sequence = data.values.flatten()[0]
pattern = 'CTGCTCCAGCAC'
d = 5

#Excercise 2
sequence2 = 'GGTCCTCACAAGCACATGCCTTGTGGGGATAACAGTGTCGCCATTTCTAGTCGGAGGTATATGGAGTTGACATCGGAGATTTCCCGCGCTAAAGTCTACGGATATCAGTATGGGACTAATGTTGTGGCCTAATACAATGCGGGCGAGAAGCCTTTTTACAGTATTTGCTTTTAACAACTCAGGGGGATTGGGAGATTTTTGCTTTGCACGAATATCCCAGCATGCTTTCGGTGATCCCATCGTGCTTGATTGTTACATAGCGCTGGGTCAGCCGTACACGTGCAAAGCTTCGGTGCAGGTTAGGCCTACTG'
pattern2 = 'GTATTTG'
d2 = 3

freq_pattern_index = aprox_pattern_matching(sequence2,pattern2,d2)
freq_patterns = len(freq_pattern_index)
print(freq_pattern_index,freq_patterns)


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 8.5. Neighborhood of a string
'''
    pattern - sequence
    d - hamming distance max.
    Output: The collection of strings Neighbors(Pattern, d)
'''
def neighbors(pattern, d):
    if d == 0:
       return pattern
    if len(pattern)==1:
       return {'A','C','G','T'}
    neighborhood = []
    suffixNeighbors = neighbors(pattern[1:],d)
    for text in suffixNeighbors:
        if calculate_hamming_distance(pattern[1:],text)<d:
            for nucleotide in 'ACTG':
               neighborhood.append(np.concatenate((nucleotide,text),axis=None))
        else:
           neighborhood.append(np.concatenate((pattern[0],text),axis=None))
    txt_neighborhood = []

    for i in range(0,len(neighborhood)):
        txt_neighborhood.append(''.join(neighborhood[i]))

    return txt_neighborhood

test1_pattern = 'ACG'
d_test1 = 1
print(neighbors(test1_pattern,d_test1))


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 9. Frequent Words with Mismatches Problem.

def max_freq_patterns_hammimgd(sequence, k, d):
    freq_map = {}
    len_pattern = k
    for i in range(0,len(sequence)-len_pattern+1):
      window_actual = sequence[i:i+len_pattern]
      if window_actual in freq_map:
        freq_map[window_actual] += 1
      else:
        freq_map[window_actual] = 1 
    patterns = list(freq_map.keys())
    frequencies = list(freq_map.values())
    


    max_actual = frequencies[0]
    for i in range(0,len(frequencies)):
        if max_actual < frequencies[i]:
           max_actual = frequencies[i]  
    max_pattern_freq = {}
    for i in range(0,len(frequencies)):
        if frequencies[i] == max_actual:
           max_pattern_freq[patterns[i]]=frequencies[i]

    return max_pattern_freq

