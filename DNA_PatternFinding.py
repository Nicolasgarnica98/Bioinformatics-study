
#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 1 .Counting patterns in a sequence
def PatternCount(Text, Pattern):
    count = 0
    window_len = len(Pattern)
    for i in range (0,len(Text)-window_len+1):
     window_act = Text[i:i+window_len]
     if window_act == Pattern:
      count += 1
    return int(count)

txt1 = "GGTATTGTCTGAGAGATTGTCTGGTTTGTCTGTTCCGTGTTTGTCTGTTGTCTGATTGTCTGTTGTTTGTCTGTTGTCTGCGATTGTCTGTTGTCTGATTGTCTGACCATTGTCTGGTTGTCTGATACGGGTTTGTCTGTGTGTTGTCTGTTTGTCTGCGACGGTGTTGTCTGTTGTCTGCAATTGTCTGTTCTTGTCTGTGGTCTTGTCTGGTTGTCTGCTTTATGGGTGTTGTCTGTTGTCTGACACTTTGTCTGCTTGTCTGTTGTCTGTTGTCTGACTTGTCTGAATTGTCTGATTCTTGTCTGCCATCCCGAACATTGTCTGATTGTCTGCATTGTCTGTTGTCTGTTGTCTGATTGTCTGAGTTTGTCTGCTAGTTGTCTGATCGTTTGTCTGGTTGTCTGTTTGTCTGCTTAAGATTTGTCTGAATTGTCTGTTTGTCTGAGCTTGTCTGTTGTCTGTTGTCGCTTGTCTGCGTTGTCTGTTGTCTGGAGCCATTGTCTGGTTGCAGACCCGAAGGTTGTCTGTTGTCTGACTGGTTTGTCTGGTTTGTCTGATTGTTGTCTGAAATCAGTGCCACTAGCTTGTCTGTTGTCTGATTAATTGTCTGTACAAGTTTGTCTGTTTGTCTGGCCCTTGTCTGATTGTCTGGTTGTCTGAAGAATCTGTGGTTGTCTGCTTCCTGGTTGTCTGTTGTCTGGGCCACGTTGTCTGCTTTGTCTGCCGATTGTCTGATTGTCTGCTGTTGTCTGGGTTGTCTGCGATTGTCTGTTGTCTGTTGTCTGTAGTTGTCTGTTGTCTGGTGTTTGTCTGGCCTTGTCTGGCTTGTCTGTTGTCTGCGCTTGTCTGTAGATTGTCTGCAACCCTTTTGTCTGGCGTTGTCTGTGTACTTTGTCTGTTGTCTGTTTGTCTGACTTGTCTGTTGTCTGTTAATCCTTTGTCTGGAGTTGTCTGGTTGTCTG"
ptrn = "TTGTCTGTT"

# print(f'The pattern {ptrn} is repeated {PatternCount(txt1,ptrn)} times in the given sequence')


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 2. Counting the frequency of patterns inside a sequence

txt1 = "CCCTCGGCCCCTCGGCTCATTCTACAATTTCGAGATCATACCTCATTCTAGATCATACCTCATTCTATGCCCGAACCCTCGGCGATCATACCTGCCCGAACAATTTCGATGCCCGAACCCTCGGCCAATTTCGATCATTCTAGATCATACCTGCCCGAACCCTCGGCCAATTTCGATGCCCGAAGATCATACCCAATTTCGATGCCCGAATCATTCTACAATTTCGATCATTCTACAATTTCGAGATCATACCTGCCCGAACAATTTCGACAATTTCGACCCTCGGCTCATTCTAGATCATACCTCATTCTATGCCCGAATCATTCTATGCCCGAATCATTCTACAATTTCGACAATTTCGACCCTCGGCTGCCCGAACAATTTCGACCCTCGGCTGCCCGAACAATTTCGACAATTTCGAGATCATACCTGCCCGAAGATCATACCCAATTTCGATGCCCGAATGCCCGAACAATTTCGACAATTTCGACAATTTCGACAATTTCGACAATTTCGACCCTCGGCGATCATACCGATCATACCTGCCCGAACCCTCGGCCCCTCGGCTGCCCGAAGATCATACCTCATTCTAGATCATACCCAATTTCGAGATCATACCGATCATACCTCATTCTATGCCCGAATGCCCGAAGATCATACCTCATTCTACCCTCGGCCCCTCGGCTCATTCTATGCCCGAAGATCATACCCCCTCGGCCAATTTCGATGCCCGAACAATTTCGACAATTTCGACCCTCGGCCCCTCGGCTCATTCTAGATCATACCCCCTCGGCGATCATACCTCATTCTACAATTTCGATCATTCTACCCTCGGCTCATTCTATGCCCGAATCATTCTACAATTTCGACAATTTCGATCATTCTATCATTCTATCATTCTACCCTCGGCGATCATACCCCCTCGGCTGCCCGAACCCTCGGCTCATTCTATGCCCGAA"
test_sequence='CGGAGGACTCTAGGTAACGCTTATCAGGTCCATAGGACATTCA'
def MaxPatternFreq(sequence, k, get_max=None):
    freq_map = {}
    len_pattern = k
    for i in range(0,len(sequence)-len_pattern+1):
      window_actual = sequence[i:i+len_pattern]
      if window_actual in freq_map:
        freq_map[window_actual] += 1
      else:
        freq_map[window_actual] = 1

    patterns = list(freq_map.keys())
    frequencies = list(freq_map.values())
    if get_max==True:
        max_actual = frequencies[0]
        for i in range(0,len(frequencies)):
            if max_actual < frequencies[i]:
               max_actual = frequencies[i]

        max_pattern_freq = {}
        for i in range(0,len(frequencies)):
            if frequencies[i] == max_actual:
               max_pattern_freq[patterns[i]]=frequencies[i]

        return max_pattern_freq
    else:
       return freq_map

print(MaxPatternFreq(test_sequence,3,True))


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 3. Complementary nucleotide sequence
sequence1 = 'TTCCCCTTATTCGCTTGTCGGTAAACAGCTATGCTCGTTGACGCTAGGTCCGAGTAGTTCGCCCGCCTAAAATGCCCCTCATGCATCGCCTAGTTCACCGCCGTTACCCGCTGCCCAAACCCAATCATTAGGGTCTCCGTATAGAATACGAGTTCCACTAGGGTAGTGAAGGCGTACTGGCTCGCACCCGCTGAATTCCTGGCGCTGATGGTTCTCCTCCTTCGGGTTCGGCGCGATTTATGAGGACTAATCGCGCAACCCCAATAACGCGCTCCGTATACTGTCGGGATCTCAGGGCCTCAGAGGAGCCTTATGAGGCAATAATGTATTTAACCCTTGCTCCTGCTCTTAAGCCGGTACAGGCGCTCAAGGAATTTGAGGGCGGACACTACCTCATTGACTGATCATGGATCATGTCTAGCCACAGGTGATGTAGCTGACATGTGAGAGAACGTAAGCATGTAACTGCCCCGTCTTGCTAGGGGTTTGTATAGCCGTACTAGCTGGAACAAAAGCTATCAGCTCGGCTTGTTTTGGGTCCCGAACATAAGCCCACCTACCTCAGAAGCTCTTGAGTATTAAAGCGGGGACGTAGGGCTTTAACTTGGTAATTGTCAGTTGTGCGGTCACACTACGTGTGTGCGAGTTATGAGCACGATATTCTAAATCAGGATGTGCTGCACCTTTTGCCTCTAAGGATTGGGCATTCCACGTTTTCGACATGTACATGCCTCAAAGTCCCCGGCCGAATGTTACAAGCCACGATCTGTCACGCCGACACGCCAATGAGCCCCCCTATTGGTTCCGCGGTAAGGTGTGAACACCGCGCCATGTTATGCTTATAACCGGCATTAGTTAGCCGACCGTCCATCGTAGTCTCCTAGCGAACTGAATTGGTACTGTTGCAGATCCAGCTCTGGGGATGCTGCGGCAGTGACATAATTGTTACTCTATCCCTGACTTACATCGTCATAAATCCAGTTGTGCAAGGGTGATTCCCTGGGGATAAACATACCACCACGGTTAAGAGACGAGTGGAGCGCCTATTCGAACGGCCCCATAGCGTTCCCGAGTTCGGTCGAGGTGTGCCTAGTCCATCCAACAGATAGATACAAAGATTAGACCGTTTGTAGGAGACTTGCCGACCAGTATCGCACCTTAGCTAGAGCGGTAAATAGTCGACAAAGACGTTCACGGGGGCATGGAATTGATCTTGGGGACGATGAGCAGCTGTTAAGATGCACTTCAAGACTCCACGTCCTACATCATTCTGCATAGGACTTACGCAAGTACTGTTCCACTCAGAGGCATATCAAAACGCACCAAATCGTGGGAATCGATAGGTGTGCTTACTCCTCCACTTCTCTCTACCTCCTCAAATCACGAACACCAAGACCAGTTGGTAAGGTCTTTGGAGCGCAGTCAACCAGATGGGCTTATAGGAATGATAGGACACTACATCCTGTCGCTTTATCCAAAATGTCACTAGAGGGTGATACTACTGTCAAATGGGTACCGAGAGGATCATAAAACCTACGGCAGAAGAAGGCGAAATTGCCGATGTGGGTGCTACTACGGGCGATATACCCTCCCGCAGGTGTCTTAGTCGGGTCAATTCTGTAAATTCCCCTTATCATGCATGACCAACCCAGCTCCAGCCAACCCGCGTGCGAGGTGGTTCTAAGCCTTATCGCGAGGTAACACCCCGGCATGTACGATTCCCACTGACGTGGAGCCGGAGGGGCATAGCCAACCGCAGTGACAGTTGCGCCGTGTCGATGATTCTGTTCTGGTAAGACATAAACGGCATTGAGTTCCGAATACTGCGAGGATACGAGAGTTTATCTGTGTACGAATCTGTGTAGAACCCGAGGGCTTGGGACCACAGATTCACGTGTTGGAATCTACAAACTTCCCATATACAATAGGCTCCTATTAGGCGCCGCGGCTTAATTGCCTTGTGTTCTGCACAGTTGCAAGAGATGGCTTCTTGTGCGCAAAACCCGACTCCTGGTGGGTTCCGAGGTGAATGCATTGATCGCTGTCAGTCCTCTCAGACAAGGTTGAATTACCCGGTGTTAGCTAAGCTAGACCTGAGGGGTCCCACTTGTGCCTAGTTGAAAATATTCATGGTTATTGCCCTTAAGCAGTGGAATCTTGGGCCATGAATACCATAACATTGAGCGTCTGTAGTCGGCTGGGGTAGATACCCGAGTGGCTGTCGCCTCACGTGGTCGCACAGTCACGATAACGGAGACCTCTCCGCACACCCTAGATAGCCTATCCAAGGCTTCTAGGTAATCTCCCCTGACTGCCATTTGCGGCTCGAGCCATCCCAAATGGGCCTTTCGAAGCAAACTCCAAACGGTGGTTTCAATATTGGAGTTTACCGCCGCAGATAAGACCGGACTGTCACCACTGCATTTAATGAGAGATTGTGCCCGGACCTCGCAGCTCCGGTCTCCTGTGCGGACTTTACCCGAGTAATTGTGACCTTTCCGCACTGTCATGAGAACTTATTATGGGGCTTAACCGTATGTAAGAGGATCGCCCGGAAAACATGGGAGACATGCAGTCGCTTGGGACGTTCGCCACAGTCCCTCCTCTGTCCTCCGTCCCGCCGTCACGTATATCTGGGGAGCGTGCGAGGTCGTGGCACTAGGGGACCTGATATCTAGTTCAAGTCCTTAATTTTCGAGACTCTACGACAATCACTGGCCCTTTTAATATTAATGTGGGGTCTCCATTATCGTTAGTGCTAGATCAAACACCTTACCAGAAAAGGCCGTGATTGGAAAGGTTCACATGACACACCTAAGCGCATCGTGCTACGTCTGGTTTGTACCTTATTTCTGCAAGCTGCCACCACTAGGGCTGTGTCGGAGAGAGTTGTTTAATCCACAACCGATTATCCCTGCAGAGGGAAGTCCCACATTCGCAATCCAAGTAGGTGCGCCTTGTTCTGCTGCACTTACCATTTCTACAAATGAACCGGACGTCTGTTGCTGCTGGCTGGAGATAAGCACACCCGATACAGGGGCCTCCCTTGCCGCCCTTACGAGAGAGACCATTGACAACCGAATACGAATGTTGGGCTCTAGACCTTGTAGAGGCACGAAAATCTCTTAACACCAGAGTGCATACACATGTACTCCCACTTACATGTTCTCACGGGCATCCTAAGGCATGGCATGTACGTCACGATGGATGCGGAAACAGCCGGCCGTCTACTACATCATTGTGCTCGGAATATGATGTGAATGGTACTTGCCAGTGGCCTTCTGATTCCAGAAAATTAACAAACAGTTCGATACGCTCTTAAAACAAGCGGGAGAGGCCGACCCTCGTTGGAGGTGATTTCAACCACACTGCCGCACCCCGTGCCGGGGTTTGCCCCTATCTTGCGCACGAGTCTATGTCTCGACCGTAGGATCCGTTCACAAGGCACTTGGGCCCACCCGGGTAGTCGGGGTATCGGTTATGTGGCTCTAGGATGGTAATTAACTAGTGAGACCTCGTACCTGTCCTACGCCACGTTTCGGTCCGTCAGCCGCCAGCTGCTTAGAGACACGAGTAATATTAGAGCGACTGTGCGTACTCTGTAGTGGAAAGGGAAAACGGTATGAGGCAACTAAGCTCACTCATCGTACTGGGCAATTCAAGCTGGAAAGCGAACGTACCATCTACGATTGAGCGTTGACCAGTCTATCAATACATACTAGCGTAAACGTTCCGTGCCAACCAGAGTACACTACACGTTAGTAGTTCGCATACTGCGACATCGCTACGTGAAGCCTGCCACGCATCACATAATTTCATAAACTATAGGATAGTTCACTCGGGTTCAACTACAATACCGGAACGTGGGAGAGTGGAGTATTATAGTAATTTAAACCCTTCTTAACTCACTATAGAGAAATTCCTGAAGGATTACCGCCTACAAAGAACAAAGTGTGCTAAATCAGAAATATAACTTCACAAGGCCTGTGTATCTGTTATCAATTTGTTGGTGTTAGCTTTATTGTATATAGAATAGGGGACGCCATTGTAACGCGCAGTCCGAAGTGATTGTGTCCTTAGTACATTTATTAGCTACTCAATCCATGAATTGGCGACATCCCGGTCATTAGCCTCTGTTCGCATAGATACGACGCGCCGGCCTCTGGAGCACTCGTGTCCCACTAAGCCATCGATCTGAGCTGCGCGTATCAGGTTCCTGCCCTACTGTGCCAGTACGCTTGTGTGAGGTGATCACCTAGCTCTCATGACAGACACATCATGCTCCCAACTCTTCATAGTAAGGTGGGGGGGCCCAACTCCAGACCAGTTACTACACAACGCATGCTCTTTATTTTGCCCTGCATGTCGTTTGGAGCGTTACCATTTTTGCGTGTACTCGTTTATCCAGTGACATGTCAGGGAAAGTGCTAGAATAGATCCGACGCAGCACCGGCTTAGTCATTGGCGCGTCTACCTGATTCAATCGCCTATTCGGCTGATCTTTCTTTGGTATGCGAGTCCAGTAGGCCGCGGCCTTGGTAGTCCGTTACTCGTGCGGCTCGTGCATCCGTTATAGATGGTAGTTCACGTTTCTTGCCCCCCAAAGTACTCCTTCCCTTTACCCCTCCCTGGAGTAATATAAGTTAACTAACTTTCTGACCGTATGCATCGTGCACAAACCACAGTTCAAGCGCGGTTGCTGCCAGGGTCTCAGATGTATTTTGTCTTATTGACGGCCTTGTCCCGTTATAGCAACGATGAGGGTCAAACAGTATAAGTCGACTATTGAAACTAGGGTAGGACCAGAACCATTATGGTGGAAATAGGCACTCTTGAGTAAGCTTCGCGAGCGTAGCTGATATGGCCATGCAAATAATAGTCTTTGGGTCCAACATGATAGTCTGTTCTCGGTTATAGCAGGTGGACCAACAGATTTAAACGTTCCTGACTATTAGCCTGGAAGCAAGCCGAGAAGACATTTACCGAATGCCTATGATCACGCGCCTCACAAGGCGTCGAACAAGATTTCCGTCTGAGGGCAGGCGGTCTGGGGCGCTATCCTGGTAAGACTGACAATTATCCGGGTTGTTGGGTTGGCGTTTAATGAGCCACGAACGGTCTTCATCTAATGTACAGCGTTAATTCGTGACGGTCAGTCGTTAACGGGCTCATATTGGTTTGGATACAACGGACAGGTTCAGATAATAATACAGCAGCCGCCCGATGATATCAGCCTTCGGGATACCACCCCTGTGGTGATAACTACGTAGATCTACCGCGCAGCAATTGTGAGAAGGTTCCTGGCGGGGGCACCTCCTCATGTCATGAAGGGAGGAAGCGCTCACTTCGGGTTTCGAGCTCGGCCCACAGCACCTTAGGACCGGTGATGCACATACTAGGAATGAAAATCCTGAGAGGAGTCGAGCACAACACTTCTCGGGTTCGGAGTTATCCTAATTATGAATAGGATGTCATTTGACCGAGTTAAGTTTGCCAACACTATCAAAGGCATACTACGTTCGCGCAAAGCCGGCCTAGAGGACTGAGATAGTCGTAGCGTCTCTTAGAAGGGATTCTACCGTGCCGTCGCTATGGGGGTTATATCGCAGTCGCTCTGAAATGGAATGTCCTGACAGTACGTCATGAGCAGATGGCGACTGGTGAGACCTTCGGCTCCATTACTTGAGGCCCATACCCGGGATCCCCACATCCCTCGGTATGTCCCTCGTCCTTAGTGTGTCGCGTATATCGCTACCGAGGGGATAAGTATATAGTTCGAGGGCCCTCAGGAGGTACGTATGTTTTGTCAACGTTTATAGCCCAATTAACCGGGGGGGGTGTTTGTCTACTCCGTACATCCACAGAACCCTCGCGCAAACCCAGAACGATGATAACCTGTCTCCCTTTTGCGACAGTATATGCGGCCATAATTCTCTGGGGAGGTTTAAAAGCAGAAGAGCGTGCATCCTCGCTTCCGGAGGCGGCCAACCTGGATGATACCGGTCGGCCAGTTAACGTACAAAAGTAACATAGAGGCATAGACAGTTACGTGCAGTTCATGAAGCCGCACCACGTGGCTGACATTTTCCACTATGCGGCCTTGTATTTCCTGACGTCCAGTAATCTGAATGCCGGGTCTTACCTAGAAACACGCCACCTCTCCCATCAGCTCTGGATGACCGCGACGGAAGGTGATGAACCTGCCACTCCTAAGTGTAAGCAGAATCGCCGCTCAATGGAGACGGCATACTATATCCCGGCCTGCCCTTAGAATCGGCACGATCTCTGCACGCGGTTAGAAGTACGAATGTGTCAACGATAGTAGTGCGTCGATCGACCTCCTCCTCAAGGCATCTAGACATGCCCGCGACTGGTAGGCACTGCTCAGAAGCAAGGAGTATGAGACCGTTGATGGTAGTTCATCAGAGGTGGGGTTCATGAGTCGTACTGATAAAAGTTGGGTCTTCATATAGTTATTTGAGTTCGGGTTACCAACAAACGCGATATGGGTAGCTGTGTGTCTAGTATTACCAGTATTCTTCTTTCAGACAGCCTGGTCGGCGTACGCCCCCGAAGTCCATAGTTAGGTCAATTCCCCAAGCTCTCAAGGTGCCTCAAGCGCGAATGCCCGTATGACGCTGAGAAAATGGTTGTAATAAGAGATGATACTACAGACGAGGATTAAAATCTATTATTGTAATTCAGGGAGATCCTTTTCTCTTCGCCGGGAACAGAAATCTCAGTACGGGCAAAATCATTGCGGGGTATGGCAGTAGTATATTCCAGCTGAAGCAGATTGACCTACCCAGAGATCTCTCCCTAAACCGTGGACTCAAAGGAAGGTGGAGCTCCACTCGGAATCACAGTCGGGAGCGTGGATCGGATGCACACAATGTCTTGAGACATTTGCTGAGCTGATTCAAGCCTACAAGACCTAGGTTTCGTTATCGGTAACTTCAAAAACGGTCCCGTTGCGGGCAAGATACCAAAGCGGGTCGAATCGATGTTGGCGACTTCCCTCCAGCGGGTCTAAGGCTTCAAGTCGTGTGGTAATGCCACTCTCCCATTTATCCGCGCTTACGCGCCTATGGCCGTTCGGAGAACGGTCATTCCAAAATTTTCAGGTGCGATCTTCATGCGCTCCGAAATGAGCAACTCGTCCCTGCTGACTGGGCGTTGTCCGAGCGAATTTCCAATAGTTTAATAGGCACGGTATCCGCTATCATTTAGTTTGGCAGCCACGGTAAAACGAGACGTTGCACTCTGTCGGTCTCAAAGAAGTTCTCCATCCTGGCGTTGCAGACTTTCCAAGCCGGTCTGTGCAGGATCTTTCTCTATTAAATTCACATGATGGACCAAATATAATCGGTTGGGAACAGAGATCAGTACTACGCCAATTAAACTCGTTGGATCGATCAGGAGCATTAACGTCTCCACGGCCCACAACAAGAACTCCGCTATAGAATAGAATTACACCCCGTCGAATAGGACTCAACCGAGGGCTTCGGACCACCGTCGTAAGCGCCACAGGCTTTCTCTTTGACGCTGTGGTGGCGAAGCCAAACGTGGTTACGCGCTCTGGACAAACCGCATATAGTATTCGCATGTAAAGGCCCTGCTGGTTCCGAGCCTGGATGCGAATAGTGAGTCCAATTAGCCAAGCTACCCTTGCGCCCCAAGGGAGGGAGTTGGATAGTGGATATAGAAAGTTATCTGTTTCAATTCTCCTGAGGTAAGAGATACACAAGTAGGCTGTTAGTACCCTAGTTAGACATGTTCCGCATAGGAGAGGCGGGAAAGTTCTTGAAGGGAAGGACCGCTAGTGTTCAATTAGTGATCAAAAACTCACCGTAGGACATTTACCGCGAGCGTGTGAACGCGACGAGCATGTCACTCAGTCCTCCGTGTTAACAACTGGATGCCACGTCCGAAGAAGGTAGATGTGCGTTATTCAGATATTTAAATAGAAAGGCATATTCTCTCTCATACGTAGGTACCTATTATCGCCACGTACAATCATGGCATTGAGATGCATGAGAGGTGCCTCACTCTGTGCTTCATACGCAAGCTCCTAAGGATATTCCAGATCGAGCACTTGCAACGCATCCCGTTGGCTAACGTATAAATACGGGGGGAACGACCAGTCTTGACAGATTGACTTAGGGACGGGGTCATACGTATTATTCGCATGGGAACCATGAGAAAGTTGCTCGAGAACCGCCTTCCGAGTGCGCTTGTTTACCCGTATACGTCTATTGACCCCGTTGAGACCTATCTCTTTCGAATAGGGGATCCTACTTTTCTCTGGACAGGGTACTTCTGAAGTCGGTCGAAACGTCAGAACTTTCGAGTGTGATTCAGTCGGTTACGTAATTAAACTTGATTGAAGGCTTGAGAAGAATTTGGGCCACTCTTCGGTCCGCTCGAACGGCGCGTGAGGGTCTCAAATGATGCACCGCTGTCCCGGCATAAGATCGTCCCCTACACATTATTGGAGCCTGCCACGAGATTCGCTAGCGAAAGGTAAAAGCGAATCTGACGCTCAGATCCGCACCTTGTCCCTAAATCAATCGCGGCGAGCCTGTCAGGTACTGGCTACTCAAGATCCTACGTAGGTGACGCGCTATGAACAGACGCCACTATCGTTTACGGGGCTTACGAAGATTTGACGGGTCGATGAAATCGAACTGCGGTGCGCCCAGTGCTCACCAGTTATAGCGAGAATGTATGGGACCGATTTGCTCAGTACAGGGTTCTACCACTTTGGATGCAAAGCATCTAGCCCATGTATACATGTTGGACTCATATTTCGTTGGAGCGCAATTGTTGGGGTATCACTTGAGTAAAAGAGACCATCGCCTCAAGTCCCATGGGCTGATGTTAGTCCATGCTAATTTCTGATACAGAACGGTCGCAGCCTCCACGGGCCGTGGGCCCGTCCGGAAGGCAGGGTTTCCGTACATGCCGTACACATGTGCAGTGCTCTTCAGTCCGCGCTGTATGTTCTGTGGTCGTTCGCCG'
test_sequence2 = 'TTGTGTC'
def get_complementary_sequence(dna_template_sequence):
    dna_complements = {'A':'T','T':'A','C':'G','G':'C'}
    dna_complementary_sequence = ''
    for nucleotide in dna_template_sequence:
       comp_nucleotide = dna_complements[nucleotide]
       dna_complementary_sequence = dna_complementary_sequence + str(comp_nucleotide)

    #Flip the sequence to read 5' -> 3'
    reversed_dna_complementary_sequence = dna_complementary_sequence[::-1]

    return reversed_dna_complementary_sequence

print(get_complementary_sequence(test_sequence2))


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 4. Pattern finding for an specific pattern on a genome
import pandas as pd
data = pd.read_csv('./Data/Vibrio_cholerae.txt',delimiter='\t',header=None)
sequence2 = data.values.flatten()[0]
pattern2 = 'CTTGATCAT'
pattern3 = 'ATGATCAAG'
def pattern_finding(pattern, dna_sequence):
    pattern_len = len(pattern)
    patternFinding_dna_index = []
    for i in range(0,len(dna_sequence)-pattern_len+1):
       actual_window = dna_sequence[i:i+pattern_len]
       if actual_window == pattern:
          patternFinding_dna_index.append(i)
    space_separated_string = ' '.join(str(element) for element in patternFinding_dna_index)
    return space_separated_string

# print(pattern_finding(pattern2,sequence2))

#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////# 5. Clump finding algorithm
#Genome sequence -> the dna sequence where we want to find clumps
#k -> lenght of the k-mers to find
#L -> lenght of the window
#t -> threshold of how many k-mears should form a clump in the sequence.

import pandas as pd
from tqdm import tqdm
data = pd.read_csv('./Data/EColi_genome.txt',delimiter='\t',header=None)
sequence = data.values.flatten()[0]

# sequence = 'TCCACCGTGACCTCTGCAAATTATTATAGCTCTGCAAATTTAACCTTGGTGATCAGGAAGCGAAGCGCGAAGCGAATGGTACTGTTTTACACGAGACCCCGTTCCCATCTCCCCGGTGTATTCTGCGAAATACAAGCGGCGAGCGCGGCTGCCCGAAAACCAGATCAATCTATGGCCAGGTAGCCGGCTTGCCGTTGCCGCACAGGCAAGTCCATACTTTAGGCCGTCGCGATCACCAGTCTGTACGCGATATGGAAAGGTAAATCGTTAAACCTGCTAGCGGATCTATTTTTGCGATGATCTATTCACTGTAAAATGCTGCGCAGCCAATAAATTGGGACGCGTAATAATTGCCCCACACGTTGGCTACCGCGTATCGCCAGATCAGCTCTTTGTGCAATTTGCTCCTCTTCAACACTCATGACGTGCGCGCTTATCTCATCGCGCACCTTTATTAAGGCCTGCTAGTAAGCAAGCGCTGGCAACTAGGGAAGGGCTTCTTGCGGCACAAGATACGTCGCAGTCTGCATAGATCCCCCCCTGATGCTCTGATGTCGATCTGATGTCGGGTCCGCACATGTCGCCAATCGCCGAGGTTGTCAGGCATCCTTAAAACATTCCCCCTAAGTTCGCAGGCCTGTTGAGAGCGATGGGTTTAATCCGGATGGCTTGTTGGAGAAGGAGGAGCCGTTAGCTGTGGAGGCTAGCGTTCGCTGTTCGCTGGCTGGCCGCTGGCCACACTGCCACACACACACTGCCAGTTCCGCTATCCCTGATTAAGTCCGTTACTTCACACTTTATTACGTGCCTGATAACAGCTATGTTAGACTAGATAAGACTGACACTGACCGCACACACTGACCGCGTCGGTATTGAACGCATTTACCTTGGCGGAAGAACATTACCTCATATTAAGGAATAAAGCGCTCCCAGACCAGCGTACTGGGCCTGGGAGCGCCTATTCTAAGTAAAACGTATCCGAATTGTGTGTTGTTCTACGAGGAACCGGGCAGCCCGTCCTAGTCTAGAGAGTGTGCACCAGGATGTTGGCTCATACTAACCCTAATGCCTGCCTGCCTCGGCCCGCCTCGGCGCCTGAGCCCTTGTGGACTTGCTGTGTTAATACCCGGCCGCAATCGTCAAAAGGGCCTCATTGTCGGGATGACAGGATCTTCCGATCCTAGCTTATCGGCCTAACCTACGACAAGTTGTATGGACTGGTAATCTGACGTGGAGTGGCGTCGGCTTCTTCACTGGCGACTTCACTGACTGTCTTGCAGTGTTAATCTACCTCCTTCGGTGCTACGTCAGGTGATGGTGTGCTGTTGGGACAATGTTCTCCGCACAAATGCCGAACGGGAGGTGAGTAACTTTAACAACTTTAACACAACAACCTACAAATTCACTTACGATGGTCTTAAACAAACACTACAACTAGCGCAAAAAACTGTCAGGAATCCTGGAGTCTTTAGGCGGTACATAAGTACAATATTTCGAGGAATGGCCGGCGCAGGACCACGATAGGCTCGGAGCGACGTCTTTAGTAACGCACCACCCCGAACTTTATCGATGCAATTTAGCAGTGTTGATGTCATTTAGCACGCTGAGTCTGCGTTTATACAAACGGGGACGGATCCGGGCACCAACTGTAGGATGTATCACTGACTTACGATCCTAGACCCCTACGGCACAAGCTTTTCGGCTTTTCGGCTTTTCGGCTTTTCGGCTTTTCGGCTTTTCG'
k = 9
L = 500
t = 3

def sequence_clump_finder(genome_sequence, k, L, t):
    clump_patterns = {}
    for i in tqdm(range(0,len(genome_sequence)-L+1),'Processing: '):
        actual_genome_window = genome_sequence[i:i+L]
        frequnet_patterns_window = MaxPatternFreq(actual_genome_window,k)
        frequencies = list(frequnet_patterns_window.values())
        patterns = list(frequnet_patterns_window.keys())
        for j in range(0,len(frequencies)):
           pattern_actual = patterns[j]
           if frequencies[j] >= t:
                if pattern_actual in clump_patterns:
                    clump_patterns[pattern_actual] += 1
                else:
                    clump_patterns[pattern_actual] = 1

    return clump_patterns
clumps = sequence_clump_finder(sequence,k,L,t)
print(len(clumps))



#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 6. Skew function
'''
 Funtion that counts the difference between G-C content aloing a linearized genome. This is called "Skew diagram"

'''
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

def skew_couinter_func(genome):
    skew_i = 0
    c_counter = 0
    g_counter = 0
    skew_val = [skew_i]
    for i in range(0,len(genome)):
         if genome[i] == 'C':
             c_counter +=1
         elif genome[i] == 'G':
             g_counter +=1
         skew_i = g_counter-c_counter
         skew_val.append(skew_i)

    plt.plot(np.arange(len(genome)+1),skew_val,'-o')
    plt.xlabel('Genome position')
    plt.ylabel('skew (G-C)')
    plt.show()
    return (skew_val)

data = pd.read_csv('./Data/dataset_7_10.txt',delimiter='\t',header=None)
test_genome = data.values.flatten()[0]
test_genome = 'GATACACTTCCCGAGTAGGTACTG'
genome_skew = skew_couinter_func(test_genome)

#We now that the ori of the genome should be on the more negative difference of G-C. Let's find the minimum
# of the graphic.

min_skew = np.min(genome_skew)
min_skew_indices = [index for index, value in enumerate(genome_skew) if value == min_skew]

#Remember that the position 0 of the return of function skew is 0 because we initialize skew(i=0)=0 so, the real
# positions of the genome now start from 1. in other words, genome_skew is |test_genome|+1 in lenght.

print('Minimum skew: ',min_skew)
print('Genome position(s) of the minimum: ', min_skew_indices)
print('Test genome: ',test_genome)


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 7. Hamming distance problem
def calculate_hamming_distance(string1, string2):
    hamming_dist = 0
    try:
        for i in range(0,len(string1)):
           if string1[i] != string2[i]:
              hamming_dist +=1
        return hamming_dist
    except:
       print('String1 and string2 do not have the same lenght')


string1_test = 'GGGCCGTTGGT'
string2_test = 'GGACCGTTGAC'

sequence_test1 = 'CCTAACCGTGAGGAATACTGAATACCTGGGTCTCCCCTGAGGGCGTAGCAGTATGTCTCATGGTGTACCGGCAGTTTTAGCGGGGCAGTTCGTCGGCGTCATCCAGGGTGGGTACTACACTCTAGAGGTCCAATGGGACATAAACGTACAGGTATTAGCTCCCACCGACGGGTGCCGTTGGGAGCTTGTGTTATGTGGTGTAAGTGGGTGGTGCGGCCCCTTACTCCACGGAGTACCCATATACCCTCGTAATTAATACTTCTCATATACAACAGGAAGCCCTAACTTAGTGCCTGGGTCACATCTAGTGCGAATTTTGTCAGAACCCTCGTCGCCTACTAGTTCACGAACAGTGACAGTATACTCGTACCATTCTAAGATTCTCATTAGGACTCAAGGCATGCACGGGTAGCTGGCCCTATCGGTGCCACATCAGAGTCACTGGGCTATAGCGATCGCGCTGGACCCTCCTGATGATAATGCTGAGGACAGATGTGCCGCGGTGGTCTAACTCAACTGTTCATCATGGGTTTTCTCCACTTCCACAGCACCTGATATACCGCATGGCTGTCTGTAGCAATTATAAGGACAGATTTGCCGTACTCTGTTGGCTTCTCGGGGTTAAGTCGTGTCGGGTGACCAGCCCCGACGGCCGCTCGTCCTTAAACGGCGACGGCCGTACATGTACGAACTATACTAGACCGTCGGCGTTGACCCTCACTCATCTAAGCAAAGTTAAAGCCGCTGCCTAGTTCTACCGCTAATTGGGTATTCACATGATCTTATCCCGAGATCCCCGCTGACGTAATTCCACGGCCGCGTACTTTGTACGGCCCAATTTTCAGGCTTAGTTGACCAAGTCACAACATCGAATAGTGGGATATTGCAGTTTACCCCATCAACCTAGTTGGGCTGGCCACCGAAACGGTTTCGACCTGTGTCAAATCTGGCGATACGTGCCAGAACTGGGATCACTCTTGTCACGCCACGACTGGGTCAATGTTACAGCTGGGCCATGCTGACACCCCCTGTGG'

sequence_test2 = 'TGCCCGCGTAATTTTCCTCCGAGGTGACGTCCATAAGTGGTATGCTAATCAGACCGATGGGCCTGCAGGCGCGTTGCTCCTTTCAGTCCACATCCCTTACATTATAGACGCGACGTACCGGGACGTGGCGCTGAAGTGATGAAGGAAGCACACTGCTTATAATCCGAAAGTAGATGCGCTGTCATGTGAAAAGAACGGCTGGGTGGAGTAATATTGGCGTATGTGTTAGTGACTTATCTCAAATAAAACCGCCGTTGCCAACTGCTAGCAATAACAGTCTTCTGCCTGATATCGCCATCATCAAAATATACATACGTCGTACTAACCGCGAAACGTACGCATAGTGATAAGTTTTTCGACGCCAGCTAGCTATCCCTTCATAGCTGTATGCCGTCAACGTAGGTGAAGATAGTTGCACATGTAGAACACCCCAAAGCATGACGAACGTGCCCGTTTCTCAGCACATATACGGCCAATCGAACGACAGAGGTGAGTAGTACGCGTCCAGGAGATCGGCGGAACCCAAGGAGGGTCATATAGAGGGGGTGAGTTCTGGTGGACTTCATATCGTCTAAGGAGCTATAGCTAAAAAATGTTCATAAGGGGCGCTATGTGCACTACACTTCTAGGATTGCAATGCTGCGCGTTTAAGGGACTTTATTTATGGTAACTGGTCGTCGGCGCTGAGCTAAGATTGTGTAGAGTTAGACAGGCACGATATCGGGGTATAACCCTAATGACTGAAAATTACAGCCTTTCATACGTTCACGCGCGTGCGCGCCTTTTTAGCTCCAGTTAGTCCTCCTATGCTCAGCGAAACAGCACCGAGGTGGCTCAGAAAATGTGCCGCATGGCTCCTTGTTAGTTGTAGCTGGTATACAATGGCGTTGAAGGAGATTGCCCGCGCAGTTGTAGAATGAATCGTGTCTGCGCAATGTTCCTGACTGTTCGTTTTCAGTGAGTGCGCGTCAGAGGCTTGGGGTACAGGTAGTTGACGTACCTAATACAACAACGCGCCATGTCTGTTGCAAGGA'

test1 = 'CTACAGCAATACGATCATATGCGGATCCGCAGTGGCCGGTAGACACACGT'
test2 = 'CTACCCCGCTGCTCAATGACCGGGACTAAAGAGGCGAAGATTATGGTGTG'

print(calculate_hamming_distance(test1,test2))


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 8. Approximate Pattern Matching Problem
#d - Max variation to consider for the hamming distance
'''''
    This function will print the index of the genome where the pattern matches with at most d variations with the
    genome,
'''''

def aprox_pattern_matching(sequence, pattern, d):
    pattern_len = len(pattern)
    patternFinding_dna_index = []
    for i in range(0,len(sequence)-pattern_len+1):
       actual_window = sequence[i:i+pattern_len]
       hamming_distance = calculate_hamming_distance(actual_window,pattern)
       if hamming_distance <= d:
          patternFinding_dna_index.append(i)
    # space_separated_string = ' '.join(str(element) for element in patternFinding_dna_index)
    return patternFinding_dna_index


#PARAMETERS

#Sample try
sequence_test = 'TTTAGAGCCTTCAGAGG'
d_test = 2
pattern_test = 'GAGG'

#Excercise 1
import pandas as pd
data = pd.read_csv('./Data/dataset_8_10.txt',delimiter='\t',header=None)
sequence = data.values.flatten()[0]
pattern = 'CTGCTCCAGCAC'
d = 5

#Excercise 2
sequence2 = 'GGTCCTCACAAGCACATGCCTTGTGGGGATAACAGTGTCGCCATTTCTAGTCGGAGGTATATGGAGTTGACATCGGAGATTTCCCGCGCTAAAGTCTACGGATATCAGTATGGGACTAATGTTGTGGCCTAATACAATGCGGGCGAGAAGCCTTTTTACAGTATTTGCTTTTAACAACTCAGGGGGATTGGGAGATTTTTGCTTTGCACGAATATCCCAGCATGCTTTCGGTGATCCCATCGTGCTTGATTGTTACATAGCGCTGGGTCAGCCGTACACGTGCAAAGCTTCGGTGCAGGTTAGGCCTACTG'
pattern2 = 'GTATTTG'
d2 = 3

#Test
test1 = 'TACGCATTACAAAGCACA'
pattern_test1 = 'AA'
test_d = 1

freq_pattern_index = aprox_pattern_matching(test1,pattern_test1,test_d)
freq_patterns = len(freq_pattern_index)
print(freq_pattern_index,freq_patterns)


#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 8.5. Neighborhood of a string
'''
    pattern - sequence
    d - hamming distance max.
    Output: The collection of strings Neighbors(Pattern, d)
    
'''

#By recursion
def neighbors(pattern, d):
    nucleotides = {'A','C','G','T'}
    if d == 0:
       return [pattern]
    if len(pattern)==1:
       return nucleotides
    neighborhood = []
    suffixNeighbors = neighbors(pattern[1:],d)
    for text in suffixNeighbors:
        if calculate_hamming_distance(pattern[1:],text)<d:
            for nucleotide in nucleotides:
               neighborhood.append(np.concatenate((nucleotide,text),axis=None))
        else:
           neighborhood.append(np.concatenate((pattern[0],text),axis=None))
    txt_neighborhood = []

    for i in range(0,len(neighborhood)):
        txt_neighborhood.append(''.join(neighborhood[i]))

    return txt_neighborhood

test1_pattern = 'AGGT'
d_test1 = 0
pattern_neighbors = neighbors(test1_pattern,d_test1)
# space_separated_neighbors = ' '.join(str(element) for element in pattern_neighbors)


test_pattern ='CCAGTCAATG' 
d_test = 1
pattern_neighbors = neighbors(test_pattern,d_test)

print(pattern_neighbors)
#%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 9. Frequent Words with Mismatches Problem.

def max_freq_patterns_missmatches(sequence, k, d):
    freq_map = {}
    len_pattern = k
    max_patterns = []
    for i in range(0,len(sequence)-len_pattern+1):
        window_actual = sequence[i:i+len_pattern]
        neighborhood = neighbors(window_actual,d)
        for j in range(0,len(neighborhood)):
            neighbor = neighborhood[j]
            if neighbor in freq_map:
               freq_map[neighbor] += 1
            else:
               freq_map[neighbor] = 1
    m = max(freq_map.values())
    for key_pattern in freq_map:
        if freq_map[key_pattern] == m:
           max_patterns.append(key_pattern)

    return max_patterns

test_sequence = 'CAGTGTTTGTTGGTTCAGCAGGGTTCAGAACCAGGGTTAACGGTTCAGAACCAGCAGAACAACGGTTCAGAACCAGCAGCAGGGTTCAGGGTTCAGCAGTGTTCAGAACCAGGGTTGGTTCAGAACAACCAGCAGCAGCAGCAGCAGCAGGGTTTGTTCAGGGTTCAGTGTTTGTTTGTTCAGCAGCAGTGTTAACCAGTGTTCAGCAGCAGCAGAACGGTTCAGCAGCAGTGTTGGTTAACAACAACCAGGGTTCAGCAGCAGCAGCAGGGTTCAGTGTTCAGAACAACCAGCAGGGTTCAGCAGCAGAACGGTTGGTTGGTTCAGTGTTGGTT'
k_test = 6
d_test = 2

print(max_freq_patterns_missmatches(test_sequence,k_test,d_test))




 #%%//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 # 9. Frequent Words with Mismatches and sequence reverse complement Problem.

def max_freq_patterns_missmatches_reversecomplements(sequence, k, d):
    freq_map = {}
    len_pattern = k
    max_patterns = []
    for i in range(0,len(sequence)-len_pattern+1):
        actual_pattern = sequence[i:i+len_pattern]
        reverse_pattern = get_complementary_sequence(actual_pattern)
        neighborhood_pattern = neighbors(actual_pattern,d)
        neighborhood_reverse_pattern = neighbors(reverse_pattern,d)

        for j in range(0,len(neighborhood_pattern)):
            neighbor = neighborhood_pattern[j]
            if neighbor in freq_map:
               freq_map[neighbor] += 1
            else:
               freq_map[neighbor] = 1

        for k in range(0,len(neighborhood_reverse_pattern)):
            neighbor_ = neighborhood_reverse_pattern[k]
            if neighbor_ in freq_map:
               freq_map[neighbor_] += 1
            else:
               freq_map[neighbor_] = 1

    m = max(freq_map.values())
    for key_pattern in freq_map:
        if freq_map[key_pattern] == m:
           max_patterns.append(key_pattern)

    return max_patterns

test_sequence = 'ACTTCCTTCCTGAGAACTCTGAACTACTTCGACTGACTAGCTCGAACTGATCCTTCCTGAACTAGCCTCTCTACTGAAGCACTAGCGAACTGAGAAGCGAGACTTCCTACTAGCCTTCCTAGCTCGAACTTCTCCTAGCACTCTTCACTGATCACTTCCTCTTCAGCCTCTGAAGCAGCCTGAACTTCTCGAAGCAGCACTGATCGAAGCTCTCTC'
k_test = 7
d_test = 2

print(max_freq_patterns_missmatches_reversecomplements(test_sequence,k_test,d_test))

